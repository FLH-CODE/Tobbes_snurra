<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>FOJAB/Återbruk</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: #ffffff;
      overflow: hidden;
      height: 100svh;
    }

    #svgObj {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100svh;
      background: #a0a0a0;
      -webkit-tap-highlight-color: transparent;
      outline: none;
    }

    /* Fullscreen toggle button */
    #fsToggle {
      position: fixed;
      top: 0.75rem;
      right: 0.75rem;
      z-index: 9999;
      padding: 0.4rem 0.7rem;
      border-radius: 999px;
      border: 1px solid rgba(0,0,0,0.15);
      background: rgba(255,255,255,0.85);
      backdrop-filter: blur(6px);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      font-size: 0.8rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      user-select: none;
      opacity: 1;
      transition: opacity 0.25s ease;
      -webkit-tap-highlight-color: transparent;
      outline: none;
    }

    #fsToggle:hover {
      background: rgba(255,255,255,0.95);
    }

    /* Auto-hide in fullscreen */
    #fsToggle.fs-hidden {
      opacity: 0;
      pointer-events: none;
    }

    /* Fallback “fake fullscreen” for older iOS that lacks Fullscreen API */
    body.ios-faux-fullscreen {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      touch-action: none;
    }
  </style>
</head>
<body>
  <!-- Fullscreen toggle button -->
  <button id="fsToggle" type="button" aria-label="Toggle fullscreen">
    ⛶ Fullscreen
  </button>

  <!-- External SVG -->
  <object id="svgObj" type="image/svg+xml" data="image.svg" tabindex="-1"></object>

  <script>
    // --- Platform detection ---
    const isIOS = (() => {
      const ua = navigator.userAgent || navigator.vendor || window.opera;
      const iOSDevice = /iPad|iPhone|iPod/.test(ua);
      const iPadOS13Plus = (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
      return iOSDevice || iPadOS13Plus;
    })();

    function supportsNativeFullscreen() {
      const el = document.documentElement;
      return !!(el.requestFullscreen || el.webkitRequestFullscreen || el.msRequestFullscreen);
    }

    // --- Fullscreen handling ---

    function getFullscreenElement() {
      return document.fullscreenElement ||
             document.webkitFullscreenElement ||
             document.msFullscreenElement ||
             null;
    }

    function isFullScreen() {
      // For native fullscreen
      if (getFullscreenElement()) return true;
      // For our iOS faux fullscreen mode
      if (isIOS && document.body.classList.contains('ios-faux-fullscreen')) return true;
      return false;
    }

    function enterFullscreen() {
      const el = document.documentElement;

      // iOS fallback: no Fullscreen API -> fake fullscreen
      if (isIOS && !supportsNativeFullscreen()) {
        window.scrollTo(0, 1);
        document.body.classList.add('ios-faux-fullscreen');
        return Promise.resolve();
      }

      if (el.requestFullscreen) {
        return el.requestFullscreen();
      } else if (el.webkitRequestFullscreen) {
        return el.webkitRequestFullscreen();
      } else if (el.msRequestFullscreen) {
        return el.msRequestFullscreen();
      }

      return Promise.resolve();
    }

    function exitFullscreen() {
      // iOS fallback exit
      if (isIOS && !supportsNativeFullscreen()) {
        document.body.classList.remove('ios-faux-fullscreen');
        return Promise.resolve();
      }

      if (document.exitFullscreen) {
        return document.exitFullscreen();
      } else if (document.webkitExitFullscreen) {
        return document.webkitExitFullscreen();
      } else if (document.msExitFullscreen) {
        return document.msExitFullscreen();
      }

      return Promise.resolve();
    }

    let fsHideTimeout = null;

    function scheduleHideFsButton() {
      clearTimeout(fsHideTimeout);
      if (!isFullScreen()) return;
      fsHideTimeout = setTimeout(() => {
        const btn = document.getElementById('fsToggle');
        if (btn) btn.classList.add('fs-hidden');
      }, 2000); // hide after 2s of fullscreen
    }

    function showFsButtonTemporarily() {
      const btn = document.getElementById('fsToggle');
      if (!btn) return;
      btn.classList.remove('fs-hidden');
      scheduleHideFsButton();
    }

    function updateFsButton() {
      const btn = document.getElementById('fsToggle');
      if (!btn) return;

      if (isFullScreen()) {
        btn.textContent = '✕ Exit fullscreen';
        showFsButtonTemporarily();
      } else {
        btn.textContent = '⛶ Fullscreen';
        btn.classList.remove('fs-hidden');
        clearTimeout(fsHideTimeout);
      }
    }

    function toggleFullscreen() {
      if (isFullScreen()) {
        exitFullscreen().catch(() => {});
      } else {
        enterFullscreen()
          .catch(() => {})
          .finally(() => {
            // Some Android browsers might take a moment; we update when events fire too
            updateFsButton();
          });
      }
    }

    const fsBtn = document.getElementById('fsToggle');
    if (fsBtn) {
      fsBtn.addEventListener('click', function (e) {
        e.stopPropagation(); // don't interfere with SVG click handlers
        toggleFullscreen();
      });
    }

    // User activity in fullscreen -> show the button briefly
    ['mousemove', 'pointermove', 'touchstart'].forEach(evt => {
      document.addEventListener(evt, () => {
        if (!isFullScreen()) return;
        showFsButtonTemporarily();
      }, { passive: true });
    });

    // Native fullscreen events
    function onFsChange() {
      updateFsButton();
    }

    function onFsError() {
      console.warn('Fullscreen request failed');
      // If it failed, make sure we don't think we're in fullscreen
      updateFsButton();
    }

    document.addEventListener('fullscreenchange', onFsChange);
    document.addEventListener('webkitfullscreenchange', onFsChange);
    document.addEventListener('msfullscreenchange', onFsChange);
    document.addEventListener('fullscreenerror', onFsError);
    document.addEventListener('webkitfullscreenerror', onFsError);
    document.addEventListener('msfullscreenerror', onFsError);

    // Initialize label correctly on load
    updateFsButton();

    // --- Main SVG interaction logic (unchanged from before) ---
    const svgObj = document.getElementById('svgObj');

    svgObj.addEventListener('load', () => {
      const doc = svgObj.contentDocument;
      if (!doc) return;

      // Inject fade CSS into SVG for smooth transitions
      const svgStyle = doc.createElementNS("http://www.w3.org/2000/svg", "style");
      svgStyle.textContent = `
        #Text-objects {
          opacity: 0;
          pointer-events: none;
          transition: opacity 0.35s;
        }
        #Text-objects.show {
          opacity: 1 !important;
          pointer-events: auto;
        }
        /* Remove blue tap highlight and outline on mobile for clickable SVG elements */
        .HitBox, .HitBoxRotate {
          outline: none !important;
          -webkit-tap-highlight-color: transparent !important;
          tap-highlight-color: transparent !important;
        }
      `;
      doc.documentElement.appendChild(svgStyle);

      // --- SVG and camera setup ---
      const svg = doc.documentElement;
      const vb = svg.viewBox.baseVal;
      const viewW = vb.width, viewH = vb.height;
      const viewCX = vb.x + viewW / 2, viewCY = vb.y + viewH / 2;

      const camera = doc.getElementById('camera');
      if (!camera) {
        console.error('camera group not found');
        return;
      }

      const imgBack = doc.getElementById('img_back');
      const whiteWheel = doc.getElementById('white-wheel'); // <-- Add this line
      const rotateHitBox = doc.querySelector('.HitBoxRotate');

      // --- Text objects and state groups ---
      const textObjects = doc.getElementById('Text-objects');
      const Forstudie = doc.getElementById('Text-forstudie');
      const Forvaltning = doc.getElementById('Text-forvaltning');
      const Projektering = doc.getElementById('Text-projektering');
      const Bygglov = doc.getElementById('Text-bygglov');

      function setRegionTextVisible(regionName) {
        const stateIdMap = {
          Forstudie: 'Text-forstudie',
          Forvaltning: 'Text-forvaltning',
          Projektering: 'Text-projektering',
          Bygglov: 'Text-bygglov'
        };

        const stateGroupId = stateIdMap[currentState];
        const stateGroup = stateGroupId ? doc.getElementById(stateGroupId) : null;
        if (!stateGroup) return;

        const classes = ['forst', 'sen', 'hela', 'efter'];

        if (!regionName) {
          classes.forEach(cls => {
            stateGroup.querySelectorAll('.' + cls).forEach(el => {
              el.style.display = 'none';
            });
          });
          return;
        }

        classes.forEach(cls => {
          stateGroup.querySelectorAll('.' + cls).forEach(el => {
            el.style.display = (cls === regionName) ? 'inline' : 'none';
          });
        });
      }

      function setTextObjectsVisible(visible) {
        if (!textObjects) return;
        if (visible) {
          textObjects.classList.add('show');
        } else {
          textObjects.classList.remove('show');
        }
      }

      function setStateText(state) {
        if (Forstudie) Forstudie.style.display = (state === 'Forstudie') ? 'inline' : 'none';
        if (Forvaltning) Forvaltning.style.display = (state === 'Forvaltning') ? 'inline' : 'none';
        if (Projektering) Projektering.style.display = (state === 'Projektering') ? 'inline' : 'none';
        if (Bygglov) Bygglov.style.display = (state === 'Bygglov') ? 'inline' : 'none';
        setRegionTextVisible(null);
      }

      // Change order to match clockwise rotation
      const states = ['Forstudie', 'Bygglov', 'Projektering', 'Forvaltning'];
      let rotation = 0;
      let currentState = states[0];
      let rotAnimating = false;
      let camAnimating = false;
      let zoomedIn = false;

      function getStateFromRotation(deg) {
        // Map rotation to state in clockwise order
        const idx = Math.round(((deg % 360) + 360) % 360 / 90) % 4;
        return states[idx];
      }

      const easeInOut = t => t < .5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;

      function setCameraTransform(scale, tx, ty) {
        camera.setAttribute('transform', `matrix(${scale} 0 0 ${scale} ${tx} ${ty})`);
      }

      function getCurrentCamera() {
        const m = camera.transform.baseVal.consolidate();
        if (!m) return { scale: 1, tx: 0, ty: 0 };
        const a = m.matrix.a, d = m.matrix.d, e = m.matrix.e, f = m.matrix.f;
        return { scale: a, tx: e, ty: f };
      }

      function fitBBoxToView(bbox) {
        const scale = Math.min(viewW / bbox.width, viewH / bbox.height);
        const bboxCX = bbox.x + bbox.width / 2;
        const bboxCY = bbox.y + bbox.height / 2;
        const tx = viewCX - scale * bboxCX;
        const ty = viewCY - scale * bboxCY;
        return { scale, tx, ty };
      }

      function animateCameraTo(target, duration = 450, cb) {
        if (camAnimating) return;
        camAnimating = true;
        const start = getCurrentCamera();
        const startTime = performance.now();

        function lerp(a, b, t) { return a + (b - a) * t; }

        function step(now) {
          const t = Math.min((now - startTime) / duration, 1);
          const k = easeInOut(t);
          const s = lerp(start.scale, target.scale, k);
          const tx = lerp(start.tx, target.tx, k);
          const ty = lerp(start.ty, target.ty, k);
          setCameraTransform(s, tx, ty);
          if (t < 1) {
            requestAnimationFrame(step);
          } else {
            camAnimating = false;
            if (cb) cb();
          }
        }
        requestAnimationFrame(step);
      }

      function setRotation(deg) {
        const existing = imgBack?.getAttribute('transform') || '';
        const withoutRotate = existing.replace(/rotate\([^)]*\)\s*/g, '');
        if (imgBack) {
          imgBack.setAttribute('transform', `${withoutRotate} rotate(${-deg},800,450)`);
        }
        // --- Rotate white-wheel together ---
        if (whiteWheel) {
          const existingWheel = whiteWheel.getAttribute('transform') || '';
          const wheelWithoutRotate = existingWheel.replace(/rotate\([^)]*\)\s*/g, '');
          whiteWheel.setAttribute('transform', `${wheelWithoutRotate} rotate(${-deg},800,450)`);
        }
        currentState = getStateFromRotation(deg);
        setStateText(currentState);
      }

      function animateRotation(targetDeg) {
        if (!imgBack || rotAnimating) return;
        rotAnimating = true;
        const start = rotation, end = targetDeg, duration = 1000;
        const startTime = performance.now();
        function step(now) {
          const t = Math.min((now - startTime) / duration, 1);
          const k = easeInOut(t);
          const deg = start + (end - start) * k;
          setRotation(deg);
          if (t < 1) {
            requestAnimationFrame(step);
          } else {
            rotation = ((end % 360) + 360) % 360;
            rotAnimating = false;
            currentState = getStateFromRotation(rotation);
            setStateText(currentState);
          }
        }
        requestAnimationFrame(step);
      }

      setStateText(currentState);

      if (rotateHitBox && imgBack) {
        rotateHitBox.style.cursor = 'pointer';
        rotateHitBox.addEventListener('click', (e) => {
          e.stopPropagation();
          if (zoomedIn) return;
          animateRotation(rotation + 90);
        });
      }

      let current = null;

      function zoomToBBox(bbox, regionName) {
        const px = bbox.width * 0.02, py = bbox.height * 0.02;
        const padded = {
          x: bbox.x - px,
          y: bbox.y - py,
          width: bbox.width + 2 * px,
          height: bbox.height + 2 * py
        };
        const target = fitBBoxToView(padded);
        animateCameraTo(target, 600, () => {
          zoomedIn = true;
          setTextObjectsVisible(true);
          setRegionTextVisible(regionName);
        });
      }

      function resetZoom() {
        setTextObjectsVisible(false);
        setRegionTextVisible(null);
        animateCameraTo({ scale: 1, tx: 0, ty: 0 }, 600, () => {
          zoomedIn = false;
          current = null;
        });
      }

      setTextObjectsVisible(false);
      setRegionTextVisible(null);

      const groups = Array.from(doc.querySelectorAll('g.region-group'));
      groups.forEach(group => {
        const hit = group.querySelector('.HitBox');
        const region = group.querySelector('.region');
        if (!hit || !region) return;
        hit.style.cursor = 'pointer';
        hit.addEventListener('click', (ev) => {
          ev.stopPropagation();
          const name = group.getAttribute('data-name') ||
            hit.getAttribute('data-region') ||
            region.getAttribute('data-region');
          if (current === name) {
            resetZoom();
            return;
          }
          current = name;
          const bbox = region.getBBox();
          zoomToBBox(bbox, name);
        });
      });

      const highlightRects = Array.from(doc.querySelectorAll('.highlight'));
      groups.forEach(group => {
        const hit = group.querySelector('.HitBox');
        if (!hit) return;
        hit.addEventListener('mouseover', () => {
          const region = hit.getAttribute('data-region');
          highlightRects.forEach(rect => {
            if (rect.getAttribute('data-region') === region) {
              rect.style.opacity = '0.2';
            }
          });
        });
        hit.addEventListener('mouseout', () => {
          const region = hit.getAttribute('data-region');
          highlightRects.forEach(rect => {
            if (rect.getAttribute('data-region') === region) {
              rect.style.opacity = '';
            }
          });
        });
      });

      svg.addEventListener('click', e => {
        const isRegionHit = e.target.closest && e.target.closest('g.region-group .HitBox');
        const isRotateHit = e.target.closest && e.target.closest('.HitBoxRotate');
        if (!isRegionHit && !isRotateHit) resetZoom();
      }, { capture: true });

      window.addEventListener('keydown', e => {
        if (e.key === 'Escape') resetZoom();
      });
    });
  </script>
</body>
</html>
