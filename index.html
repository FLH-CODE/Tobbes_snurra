<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Smooth SVG Zoom (camera transform)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: #ffffff;
      overflow: hidden;
      /* Use small viewport height for mobile fullscreen */
      height: 100svh;
    }
    #svgObj {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100svh;
      background: #a0a0a0;
    }
    /* Optionally, hide by default */
    [data-hide] { display: none !important; }
  </style>
</head>
<body>
  <!-- External SVG -->
  <object id="svgObj" type="image/svg+xml" data="image.svg"></object>

  <script>
    // Request fullscreen on first user interaction (mobile browsers)
    function requestFullscreenIfPossible() {
      const el = document.documentElement;
      if (el.requestFullscreen) el.requestFullscreen();
      else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
      else if (el.msRequestFullscreen) el.msRequestFullscreen();
    }
    window.addEventListener('touchstart', requestFullscreenIfPossible, { once: true });
    window.addEventListener('click', requestFullscreenIfPossible, { once: true });

    // --- Main SVG interaction logic ---
    const svgObj = document.getElementById('svgObj');

    svgObj.addEventListener('load', () => {
      const doc = svgObj.contentDocument;
      if (!doc) return;

      // Inject fade CSS into SVG for smooth transitions
      const svgStyle = doc.createElementNS("http://www.w3.org/2000/svg", "style");
      svgStyle.textContent = `
        #Text-objects {
          opacity: 0;
          pointer-events: none;
          transition: opacity 0.35s;
        }
        #Text-objects.show {
          opacity: 1 !important;
          pointer-events: auto;
        }
      `;
      doc.documentElement.appendChild(svgStyle);

      // --- SVG and camera setup ---
      const svg = doc.documentElement;
      const vb = svg.viewBox.baseVal;
      const viewW = vb.width, viewH = vb.height;
      const viewCX = vb.x + viewW / 2, viewCY = vb.y + viewH / 2;

      const camera = doc.getElementById('camera');
      if (!camera) {
        console.error('camera group not found');
        return;
      }

      const imgBack = doc.getElementById('img_back');
      const rotateHitBox = doc.querySelector('.HitBoxRotate');

      // --- Text objects and state groups ---
      const textObjects = doc.getElementById('Text-objects');
      // Individual region text groups by class
      const regionTextGroups = {
        forst: doc.querySelector('.forst'),
        sen: doc.querySelector('.sen'),
        hela: doc.querySelector('.hela'),
        efter: doc.querySelector('.efter')
      };
      const Forstudie = doc.getElementById('Text-forstudie');
      const Forvaltning = doc.getElementById('Text-forvaltning');
      const Projektering = doc.getElementById('Text-projektering');
      const Bygglov = doc.getElementById('Text-bygglov');

      // Show/hide all region text groups
      function setRegionTextVisible(regionName) {
        Object.entries(regionTextGroups).forEach(([key, el]) => {
          if (el) el.style.display = (key === regionName) ? 'inline' : 'none';
        });
      }

      // Show/hide text objects with fade effect
      function setTextObjectsVisible(visible) {
        if (!textObjects) return;
        if (visible) {
          textObjects.classList.add('show');
        } else {
          textObjects.classList.remove('show');
        }
      }

      // Show only the correct tl-text group for current state (rotation)
      function setStateText(state) {
        if (Forstudie) Forstudie.style.display = (state === 'Forstudie') ? 'inline' : 'none';
        if (Forvaltning) Forvaltning.style.display = (state === 'Forvaltning') ? 'inline' : 'none';
        if (Projektering) Projektering.style.display = (state === 'Projektering') ? 'inline' : 'none';
        if (Bygglov) Bygglov.style.display = (state === 'Bygglov') ? 'inline' : 'none';
        // Hide all region text groups when in rotation state
        setRegionTextVisible(null);
      }

      // --- State tracking ---
      const states = ['Forstudie', 'Forvaltning', 'Projektering', 'Bygglov'];
      let rotation = 0; // 0, 90, 180, 270
      let currentState = states[0];
      let rotAnimating = false;
      let camAnimating = false;
      let zoomedIn = false;

      // Get state name from rotation angle
      function getStateFromRotation(deg) {
        const idx = Math.round(((deg % 360) + 360) % 360 / 90) % 4;
        return states[idx];
      }

      // --- Animation helpers ---
      const easeInOut = t => t < .5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;

      function setCameraTransform(scale, tx, ty) {
        camera.setAttribute('transform', `matrix(${scale} 0 0 ${scale} ${tx} ${ty})`);
      }

      function getCurrentCamera() {
        const m = camera.transform.baseVal.consolidate();
        if (!m) return { scale: 1, tx: 0, ty: 0 };
        const a = m.matrix.a, d = m.matrix.d, e = m.matrix.e, f = m.matrix.f;
        return { scale: a, tx: e, ty: f };
      }

      function fitBBoxToView(bbox) {
        const scale = Math.min(viewW / bbox.width, viewH / bbox.height);
        const bboxCX = bbox.x + bbox.width / 2;
        const bboxCY = bbox.y + bbox.height / 2;
        const tx = viewCX - scale * bboxCX;
        const ty = viewCY - scale * bboxCY;
        return { scale, tx, ty };
      }

      // Animate camera transform (zoom in/out)
      function animateCameraTo(target, duration = 450, cb) {
        if (camAnimating) return;
        camAnimating = true;
        const start = getCurrentCamera();
        const startTime = performance.now();

        function lerp(a, b, t) { return a + (b - a) * t; }

        function step(now) {
          const t = Math.min((now - startTime) / duration, 1);
          const k = easeInOut(t);
          const s = lerp(start.scale, target.scale, k);
          const tx = lerp(start.tx, target.tx, k);
          const ty = lerp(start.ty, target.ty, k);
          setCameraTransform(s, tx, ty);
          if (t < 1) {
            requestAnimationFrame(step);
          } else {
            camAnimating = false;
            if (cb) cb();
          }
        }
        requestAnimationFrame(step);
      }

      // Animate rotation and update state
      function setRotation(deg) {
        const existing = imgBack?.getAttribute('transform') || '';
        const withoutRotate = existing.replace(/rotate\([^)]*\)\s*/g, '');
        if (imgBack) {
          imgBack.setAttribute('transform', `${withoutRotate} rotate(${deg},800,450)`);
        }
        currentState = getStateFromRotation(deg);
        setStateText(currentState);
      }

      function animateRotation(targetDeg) {
        if (!imgBack || rotAnimating) return;
        rotAnimating = true;
        const start = rotation, end = targetDeg, duration = 350;
        const startTime = performance.now();
        function step(now) {
          const t = Math.min((now - startTime) / duration, 1);
          const k = easeInOut(t);
          const deg = start + (end - start) * k;
          setRotation(deg);
          if (t < 1) {
            requestAnimationFrame(step);
          } else {
            rotation = ((end % 360) + 360) % 360;
            rotAnimating = false;
            currentState = getStateFromRotation(rotation);
            setStateText(currentState);
          }
        }
        requestAnimationFrame(step);
      }

      // Set initial state text
      setStateText(currentState);

      // --- Rotate button handler ---
      if (rotateHitBox && imgBack) {
        rotateHitBox.style.cursor = 'pointer';
        rotateHitBox.addEventListener('click', (e) => {
          e.stopPropagation();
          animateRotation(rotation + 90);
        });
      }

      // --- Zoom logic ---
      let current = null;

      function zoomToBBox(bbox, regionName) {
        const px = bbox.width * 0.04, py = bbox.height * 0.04;
        const padded = {
          x: bbox.x - px,
          y: bbox.y - py,
          width: bbox.width + 2 * px,
          height: bbox.height + 2 * py
        };
        const target = fitBBoxToView(padded);
        animateCameraTo(target, 450, () => {
          zoomedIn = true;
          setTextObjectsVisible(true);
          setRegionTextVisible(regionName); // Show only the region's text group
        });
      }

      function resetZoom() {
        setTextObjectsVisible(false); // fade out
        setRegionTextVisible(null); // Hide all region text groups
        animateCameraTo({ scale: 1, tx: 0, ty: 0 }, 450, () => {
          zoomedIn = false;
          current = null;
        });
      }

      // Hide text objects and all region text groups initially
      setTextObjectsVisible(false);
      setRegionTextVisible(null);

      // --- Region hitboxes setup ---
      const groups = Array.from(doc.querySelectorAll('g.region-group'));
      groups.forEach(group => {
        const hit = group.querySelector('.HitBox');
        const region = group.querySelector('.region');
        if (!hit || !region) return;
        hit.style.cursor = 'pointer';
        hit.addEventListener('click', (ev) => {
          ev.stopPropagation();
          const name = group.getAttribute('data-name') ||
            hit.getAttribute('data-region') ||
            region.getAttribute('data-region');
          if (current === name) {
            resetZoom();
            return;
          }
          current = name;
          const bbox = region.getBBox();
          zoomToBBox(bbox, name); // Pass region name for text visibility
        });
      });

      // --- Click outside to reset zoom ---
      svg.addEventListener('click', e => {
        const isRegionHit = e.target.closest && e.target.closest('g.region-group .HitBox');
        const isRotateHit = e.target.closest && e.target.closest('.HitBoxRotate');
        if (!isRegionHit && !isRotateHit) resetZoom();
      }, { capture: true });

      // --- Escape key to reset zoom ---
      window.addEventListener('keydown', e => {
        if (e.key === 'Escape') resetZoom();
      });
    });
  </script>
</body>
</html>
